---
title: GCC内联汇编
date: 2021-06-14 17:49:29
tags: 汇编
category: C++
---

# GCC 汇编语法
GCC  使用 `AT&T / UNIX`  汇编语法。 

## 源操作数和目的操作数顺序
`AT&T`  语法的操作数方向和 `Intel` 语法的刚好相反。在 `Intel` 语法中，第一操作数为目的操作数，第二操作数为源操作数；然而在 `AT&T` 语法中，第一操作数为源操作数，第二操作数为目的操作数。

## 寄存器命名
寄存器名称有 `%` 前缀，即如果必须使用 `eax`，它应该用作 `%eax` 。

## 立即数
`AT&T` 立即数以 `$` 为前缀。静态 `C` 变量也使用 `$` 前缀。在 `Intel` 语法中，十六进制常量以 `h` 为后缀，然而 `AT&T` 不使用这种语法，这里我们给常量添加前缀 `0x`。所以，对于十六进制，我们首先看到一个 `$`，然后是 `0x`，最后才是常量。

## 操作数大小
在 `AT&T` 语法中，存储器操作数的大小取决于操作码名字的最后一个字符。操作码后缀`b`  、 `w` 、 `l`  分别指明了字节（8位）、字（16位）、长型（32位）存储器引用。`Intel`  语法通过给存储器操作数添加 `byte ptr`、 `word ptr` 和 `dword ptr` 前缀来实现这一功能。

因此，`Intel` 的 `mov al, byte ptr foo` 在 `AT&T` 语法中为 `movb foo, %al`。

## 存储器操作数
在 Intel 语法中，基址寄存器包含在 `[` 和 `]` 中，然而在 AT&T 中，它们变为 `(` 和 `)`。另外，在 Intel 语法中， 间接内存引用为

`section:[base + index*scale + disp]`，在 AT&T中变为 `section:disp(base, index, scale)`。

需要牢记的一点是，当一个常量用于 disp 或 scale，不能添加 `$` 前缀。

现在我们看到了 Intel 语法和 AT&T 语法之间的一些主要差别。我仅仅写了它们差别的一部分而已。关于更完整的信息，请参考 GNU 汇编文档。现在为了更好地理解，我们可以看一些示例。
```asm
+------------------------------+----------------------------------------+
|       Intel Code                       |      AT&T Code                                   |
+------------------------------+----------------------------------------+
| mov   eax,1                           |  movl  $1,%eax                                   |   
| mov   ebx,0ffh                      |  movl  $0xff,%ebx                               |   
| int     80h                              |  int      $0x80                                       |   
| mov  ebx, eax                       |  movl   %eax, %ebx                             |
| mov  eax,[ecx]                      |  movl   (%ecx),%eax                            |
| mov  eax,[ebx+3]                 |  movl   3(%ebx),%eax                          | 
| mov  eax,[ebx+20h]             |  movl   0x20(%ebx),%eax                    |
| add   eax,[ebx+ecx*2h]        |  addl    (%ebx,%ecx,0x2),%eax            |
| lea    eax,[ebx+ecx]              |  leal     (%ebx,%ecx),%eax                   |
| sub   eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax   |
+------------------------------+----------------------------------------+
```

## 基本内联
基本内联汇编的格式非常直接了当。它的基本格式为：
```
asm("汇编代码");
```
示例
```armasm
asm("movl %ecx %eax"); /* 将 ecx 寄存器的内容移至 eax  */
__asm__("movb %bh (%eax)"); /* 将 bh 的一个字节数据 移至 eax 寄存器指向的内存 */
```
你可能注意到了这里我使用了 `asm` 和 `__asm__`。这两者都是有效的。如果关键词 `asm` 和我们程序的一些标识符冲突了，我们可以使用 `__asm__`。如果我们的指令多于一条，我们可以每个一行，并用双引号圈起，同时为每条指令添加  `\n`  和  `\t` 后缀。这是因为 gcc 将每一条当作字符串发送给 as（GAS即 GNU 汇编器），并且通过使用换行符/制表符发送正确格式化后的行给汇编器。

示例：
```asm
__asm__ ("movl %eax, %ebx\n\t"
         "movl $56, %esi\n\t"
         "movl %ecx, $label(%edx,%ebx,$4)\n\t"
         "movb %ah, (%ebx)");
```
如果在代码中，我们涉及到一些寄存器，但在没有恢复这些变化的情况下从汇编中返回，这将会导致一些意想不到的事情。这是因为 GCC 并不知道寄存器内容的变化，这会导致问题，特别是当编译器做了某些优化。在没有告知 GCC 的情况下，它将会假设一些寄存器存储了一些值——而我们可能已经改变却没有告知 GCC——它会像什么事都没发生一样继续运行。我们所可以做的是使用那些没有副作用的指令，或者当我们退出时恢复这些寄存器，要不就等着程序崩溃吧。这是为什么我们需要一些扩展功能，扩展汇编给我们提供了那些功能。

## 扩展汇编
在基本内联汇编中，我们只有指令。然而在扩展汇编中，我们可以同时指定操作数。它允许我们指定输入寄存器、输出寄存器以及修饰寄存器列表。GCC 不强制用户必须指定使用的寄存器。我们可以把头疼的事留给 GCC ，这可能可以更好地适应 GCC 的优化。不管怎么说，基本格式为：
```asm
asm ( 汇编程序模板
: 输出操作数 /* 可选的 */
: 输入操作数 /* 可选的 */
: 修饰寄存器列表 /* 可选的 */
);
```
汇编程序模板由汇编指令组成。每一个操作数由一个操作数约束字符串所描述，其后紧接一个括弧括起的 C 表达式。冒号用于将汇编程序模板和第一个输出操作数分开，另一个（冒号）用于将最后一个输出操作数和第一个输入操作数分开。逗号用于分离每一个组内的操作数。总操作数的数目限制在 10 个，或者机器描述中的任何指令格式中的最大操作数数目，以较大者为准。

如果没有输出操作数但存在输入操作数，你必须将两个连续的冒号放置于输出操作数原本会放置的地方周围。

示例：
```asm
asm ("cld\n\t"
         "rep\n\t"
         "stosl"
         : /* 无输出寄存器 */
         : "c" (count), "a" (fill_value), "D" (dest)
         : "%ecx", "%edi" 
         );
```
现在来看看这段代码是干什么的？以上的内联汇编是将 `fill_value` 值连续 `count` 次拷贝到寄存器 `edi` 所指位置。 它也告诉 gcc 寄存器 `ecx` 和 `edi` 一直无效。为了更加清晰地说明，让我们再看一个示例。
```armasm
int a=10, b;
asm ("movl %1, %%eax; 
      movl %%eax, %0;"
     :"=r"(b)        /* 输出 */
     :"r"(a)         /* 输入 */
     :"%eax"         /* 修饰寄存器 */
     );   
```
这里我们所做的是使用汇编指令使 ’b’ 变量的值等于 ’a’ 变量的值。一些有意思的地方是：

1. `b` 为输出操作数，用 `%0` 引用，并且 `a` 为输入操作数，用 `%1` 引用。
2. `r` 为操作数约束。之后我们会更详细地了解约束（字符串）。目前，`r` 告诉 GCC 可以使用任一寄存器存储操作数。输出操作数约束应该有一个约束修饰符 `=` 。这修饰符表明它是一个只读的输出操作数。
3. 寄存器名字以两个 `%` 为前缀。这有利于 GCC 区分操作数和寄存器。操作数以一个 `%` 为前缀。
4. 第三个冒号之后的修饰寄存器 `%eax` 用于告诉 GCC `%eax` 的值将会在 `asm` 内部被修改，所以 GCC 将不会 使用此寄存器存储任何其他值。

当 “asm” 执行完毕， `b` 变量会映射到更新的值，因为它被指定为输出操作数。换句话说， “asm” 内 `b` 变量的修改应该会被映射到 “asm” 外部。

现在，我们可以更详细地看看每一个域。